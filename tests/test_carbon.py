# coding=UTF-8
"""Module for Regression Testing the InVEST Carbon model."""
import unittest
import tempfile
import shutil
import os
import re

from osgeo import gdal
from osgeo import osr
import numpy
import numpy.random
import numpy.testing

gdal.UseExceptions()


def make_simple_raster(base_raster_path, fill_val, nodata_val):
    """Create a 10x10 raster on designated path with fill value.

    Args:
        base_raster_path (str): the raster path for making the new raster.
        fill_val (int): the value used for filling the raster.
        nodata_val (int or None): for defining a band's nodata value.

    Returns:
        lulc_path (str): the path of the raster file.

    """
    srs = osr.SpatialReference()
    srs.ImportFromEPSG(26910)  # UTM Zone 10N
    projection_wkt = srs.ExportToWkt()
    # origin hand-picked for this epsg:
    geotransform = [461261, 1.0, 0.0, 4923265, 0.0, -1.0]

    n = 10
    gtiff_driver = gdal.GetDriverByName('GTiff')
    new_raster = gtiff_driver.Create(
        base_raster_path, n, n, 1, gdal.GDT_Int32, options=[
            'TILED=YES', 'BIGTIFF=YES', 'COMPRESS=LZW',
            'BLOCKXSIZE=16', 'BLOCKYSIZE=16'])
    new_raster.SetProjection(projection_wkt)
    new_raster.SetGeoTransform(geotransform)
    new_band = new_raster.GetRasterBand(1)
    array = numpy.empty((n, n))
    array.fill(fill_val)
    new_band.WriteArray(array)
    if nodata_val is not None:
        new_band.SetNoDataValue(nodata_val)
    new_raster.FlushCache()
    new_band = None
    new_raster = None


def assert_raster_equal_value(base_raster_path, val_to_compare):
    """Assert that the entire output raster has the same value as specified.

    Args:
        base_raster_path (str): the filepath of the raster to be asserted.
        val_to_compare (float): the value to be filled in the array to compare.

    Returns:
        None.

    """
    base_raster = gdal.OpenEx(base_raster_path, gdal.OF_RASTER)
    base_band = base_raster.GetRasterBand(1)
    base_array = base_band.ReadAsArray()

    array_to_compare = numpy.empty(base_array.shape)
    array_to_compare.fill(val_to_compare)
    numpy.testing.assert_allclose(base_array, array_to_compare,
                                  rtol=0, atol=1e-3)


def make_pools_csv(pools_csv_path):
    """Create a carbon pools csv file with simplified land cover types.

    Args:
        pools_csv_path (str): the path of carbon pool csv.

    Returns:
        None.

    """
    with open(pools_csv_path, 'w') as open_table:
        open_table.write('C_above,C_below,C_soil,C_dead,lucode,LULC_Name\n')
        open_table.write('15,10,60,1,1,"lulc code 1"\n')
        # total change from 1 -> 2: -58 metric tons per hectare
        open_table.write('5,3,20,0,2,"lulc code 2"\n')
        # total change from 1 -> 3: -78 metric tons per hectare
        open_table.write('2,1,5,0,3,"lulc code 3"\n')


def assert_aggregate_result_equal(html_report_path, stat_name, val_to_compare):
    """Assert that the given stat in the HTML report has a specific value.

    Args:
        html_report_path (str): path to the HTML report generated by the model.
        stat_name (str): name of the stat to find. Must match the name listed
            in the HTML.
        val_to_compare (float): the value to check against.

    Returns:
        None.
    """
    with open(html_report_path) as file:
        report = file.read()
        pattern = (r'data-summary-stat="'
                   + stat_name
                   + r'">(\-?\d+\.\d{2})</td>')
        match = re.search(pattern, report)
        stat_str = match.groups()[0]
        assert float(stat_str) == val_to_compare


class CarbonTests(unittest.TestCase):
    """Tests for the Carbon Model."""

    def setUp(self):
        """Override setUp function to create temp workspace directory."""
        # this lets us delete the workspace after its done no matter the
        # the rest result
        self.workspace_dir = tempfile.mkdtemp(suffix='\U0001f60e')  # smiley

    def tearDown(self):
        """Override tearDown function to remove temporary directory."""
        shutil.rmtree(self.workspace_dir)

    def test_carbon_full_per_pixel(self):
        """Carbon: full run with raster_output_units set to per_pixel."""
        from natcap.invest import carbon

        args = {
            'workspace_dir': self.workspace_dir,
            'do_valuation': True,
            'price_per_metric_ton_of_c': 43.0,
            'rate_change': 2.8,
            'lulc_cur_year': 2016,
            'lulc_fut_year': 2030,
            'discount_rate': -7.1,
            'raster_output_units': 'per_pixel',
            'n_workers': -1,
        }

        # Create LULC rasters and pools csv in workspace and add them to args.
        lulc_names = ['lulc_cur_path', 'lulc_fut_path', 'lulc_redd_path']
        for fill_val, lulc_name in enumerate(lulc_names, 1):
            args[lulc_name] = os.path.join(args['workspace_dir'],
                                           lulc_name + '.tif')
            make_simple_raster(args[lulc_name], fill_val, -1)

        args['carbon_pools_path'] = os.path.join(args['workspace_dir'],
                                                 'pools.csv')
        make_pools_csv(args['carbon_pools_path'])

        carbon.execute(args)

        # Ensure every pixel has the correct total C value.
        # Pixel size is 1 m^2 = 0.0001 ha
        # Current: 15 + 10 + 60 + 1 = 86 Mg/ha * 0.0001 ha = 0.0086 Mg
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'tot_c_cur.tif'), 0.0086)
        # Future: 5 + 3 + 20 + 0 = 28 Mg/ha * 0.0001 ha = 0.0028 Mg
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'tot_c_fut.tif'), 0.0028)
        # REDD: 2 + 1 + 5 + 0 = 8 Mg/ha * 0.0001 ha = 0.0008 Mg
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'tot_c_redd.tif'), 0.0008)

        # Ensure deltas are correct.
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'delta_cur_fut.tif'), -0.0058)
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'delta_cur_redd.tif'), -0.0078)

        # Ensure NPV calculations are correct.
        # Valuation constant based on provided args is 59.00136.
        # Future: 59.00136 * -58 Mg/ha = -3422.079 Mg/ha * 0.0001 ha = -0.3422079 Mg
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'npv_fut.tif'), -0.3422079)
        # REDD: 59.00136 * -78 Mg/ha = -4602.106 Mg/ha * 0.0001 ha = -0.4602106 Mg
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'npv_redd.tif'), -0.4602106)

        # Ensure aggregate results are correct.
        report_path = os.path.join(args['workspace_dir'], 'report.html')
        # Raster is 10 x 10; therefore, raster total is as follows:
        # (x Mg / px) * (100 px) = (x * 100) Mg
        for (stat, expected_value) in [
                ('Total cur', 0.86),
                ('Total fut', 0.28),
                ('Total redd', 0.08),
                ('Change in C for fut', -0.58),
                ('Change in C for redd', -0.78),
                ('Net present value from cur to fut', -34.22),
                ('Net present value from cur to redd', -46.02),
                ]:
            assert_aggregate_result_equal(report_path, stat, expected_value)

    def test_carbon_full_per_hectare(self):
        """Carbon: full run with raster_output_units set to per_hectare."""
        from natcap.invest import carbon

        args = {
            'workspace_dir': self.workspace_dir,
            'do_valuation': True,
            'price_per_metric_ton_of_c': 43.0,
            'rate_change': 2.8,
            'lulc_cur_year': 2016,
            'lulc_fut_year': 2030,
            'discount_rate': -7.1,
            'raster_output_units': 'per_hectare',
            'n_workers': -1,
        }

        # Create LULC rasters and pools csv in workspace and add them to args.
        lulc_names = ['lulc_cur_path', 'lulc_fut_path', 'lulc_redd_path']
        for fill_val, lulc_name in enumerate(lulc_names, 1):
            args[lulc_name] = os.path.join(args['workspace_dir'],
                                           lulc_name + '.tif')
            make_simple_raster(args[lulc_name], fill_val, -1)

        args['carbon_pools_path'] = os.path.join(args['workspace_dir'],
                                                 'pools.csv')
        make_pools_csv(args['carbon_pools_path'])

        carbon.execute(args)

        # Ensure every pixel has the correct total C value.
        # Current: 15 + 10 + 60 + 1 = 86 Mg/ha
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'tot_c_cur.tif'), 86)
        # Future: 5 + 3 + 20 + 0 = 28 Mg/ha
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'tot_c_fut.tif'), 28)
        # REDD: 2 + 1 + 5 + 0 = 8 Mg/ha
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'tot_c_redd.tif'), 8)

        # Ensure deltas are correct.
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'delta_cur_fut.tif'), -58)
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'delta_cur_redd.tif'), -78)

        # Ensure NPV calculations are correct.
        # Valuation constant based on provided args is 59.00136.
        # Future: 59.00136 * -58 Mg/ha = -3422.079 Mg/ha
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'npv_fut.tif'), -3422.079)
        # REDD: 59.00136 * -78 Mg/ha = -4602.106 Mg/ha
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'npv_redd.tif'), -4602.106)

        # Ensure aggregate results are correct.
        report_path = os.path.join(args['workspace_dir'], 'report.html')
        # Raster size is 100 m^2; therefore, raster total is as follows:
        # (x Mg / 1 ha) * (1 ha / 10000 m^2) * (100 m^2) = (x / 100) Mg
        for (stat, expected_value) in [
                ('Total cur', 0.86),
                ('Total fut', 0.28),
                ('Total redd', 0.08),
                ('Change in C for fut', -0.58),
                ('Change in C for redd', -0.78),
                ('Net present value from cur to fut', -34.22),
                ('Net present value from cur to redd', -46.02),
                ]:
            assert_aggregate_result_equal(report_path, stat, expected_value)

    def test_carbon_zero_rates(self):
        """Carbon: test with 0 discount and rate change."""
        from natcap.invest import carbon

        args = {
            'workspace_dir': self.workspace_dir,
            'do_valuation': True,
            'price_per_metric_ton_of_c': 43.0,
            'rate_change': 0.0,
            'lulc_cur_year': 2016,
            'lulc_fut_year': 2030,
            'discount_rate': 0.0,
            'raster_output_units': 'per_hectare',
            'n_workers': -1,
        }

        # Create LULC rasters and pools csv in workspace and add them to args.
        lulc_names = ['lulc_cur_path', 'lulc_fut_path', 'lulc_redd_path']
        for fill_val, lulc_name in enumerate(lulc_names, 1):
            args[lulc_name] = os.path.join(args['workspace_dir'],
                                           lulc_name + '.tif')
            make_simple_raster(args[lulc_name], fill_val, -1)

        args['carbon_pools_path'] = os.path.join(args['workspace_dir'],
                                                 'pools.csv')
        make_pools_csv(args['carbon_pools_path'])

        carbon.execute(args)

        # Add assertions for npv for future and REDD scenarios.
        # carbon change from cur to fut:
        # -58 Mg/ha * 43 $/Mg = -2494 $/ha
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'npv_fut.tif'), -2494)
        # carbon change from cur to redd:
        # -78 Mg/ha * 43 $/Mg = -3354 $/ha
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'npv_redd.tif'), -3354)

    def test_carbon_without_redd(self):
        """Carbon: regression testing for future scenario only (no REDD)."""
        from natcap.invest import carbon
        args = {
            'workspace_dir': self.workspace_dir,
            'do_valuation': True,
            'price_per_metric_ton_of_c': 43.0,
            'rate_change': 2.8,
            'lulc_cur_year': 2016,
            'lulc_fut_year': 2030,
            'discount_rate': -7.1,
            'raster_output_units': 'per_hectare',
            'n_workers': -1,
        }

        lulc_names = ['lulc_cur_path', 'lulc_fut_path']
        for fill_val, lulc_name in enumerate(lulc_names, 1):
            args[lulc_name] = os.path.join(args['workspace_dir'],
                                           lulc_name + '.tif')
            make_simple_raster(args[lulc_name], fill_val, -1)

        args['carbon_pools_path'] = os.path.join(args['workspace_dir'],
                                                 'pools.csv')
        make_pools_csv(args['carbon_pools_path'])

        carbon.execute(args)

        # Ensure NPV calculations are correct.
        # Valuation constant based on provided args is 59.00136.
        # Future: 59.00136 * -58 Mg/ha = -3422.079 Mg/ha
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'npv_fut.tif'), -3422.079)

    def test_carbon_missing_landcover_values(self):
        """Carbon: testing expected exception on missing LULC codes."""
        from natcap.invest import carbon
        args = {
            'workspace_dir': self.workspace_dir,
            'do_valuation': False,
            'raster_output_units': 'per_hectare',
            'n_workers': -1,
        }

        lulc_names = ['lulc_cur_path', 'lulc_fut_path']
        for fill_val, lulc_name in enumerate(lulc_names, 200):
            args[lulc_name] = os.path.join(args['workspace_dir'],
                                           lulc_name + '.tif')
            make_simple_raster(args[lulc_name], fill_val, -1)

        args['carbon_pools_path'] = os.path.join(args['workspace_dir'],
                                                 'pools.csv')
        make_pools_csv(args['carbon_pools_path'])

        # Value error should be raised with lulc code 200
        with self.assertRaises(ValueError) as cm:
            carbon.execute(args)

        self.assertTrue(
            "The missing values found in the LULC raster but not the table"
            " are: [200]" in str(cm.exception))

    def test_carbon_full_undefined_nodata(self):
        """Carbon: full model run when input raster nodata is None."""
        from natcap.invest import carbon

        args = {
            'workspace_dir': self.workspace_dir,
            'do_valuation': True,
            'price_per_metric_ton_of_c': 43.0,
            'rate_change': 2.8,
            'lulc_cur_year': 2016,
            'lulc_fut_year': 2030,
            'discount_rate': -7.1,
            'raster_output_units': 'per_hectare',
            'n_workers': -1,
        }

        # Create LULC rasters and pools csv in workspace and add them to args.
        lulc_names = ['lulc_cur_path', 'lulc_fut_path', 'lulc_redd_path']
        for fill_val, lulc_name in enumerate(lulc_names, 1):
            args[lulc_name] = os.path.join(args['workspace_dir'],
                                           lulc_name + '.tif')
            make_simple_raster(args[lulc_name], fill_val, None)

        args['carbon_pools_path'] = os.path.join(args['workspace_dir'],
                                                 'pools.csv')
        make_pools_csv(args['carbon_pools_path'])

        carbon.execute(args)

        # Ensure NPV calculations are correct.
        # Valuation constant based on provided args is 59.00136.
        # Future: 59.00136 * -58 Mg/ha = -3422.079 Mg/ha
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'npv_fut.tif'), -3422.079)
        # REDD: 59.00136 * -78 Mg/ha = -4602.106 Mg/ha
        assert_raster_equal_value(
            os.path.join(args['workspace_dir'], 'npv_redd.tif'), -4602.106)


class CarbonValidationTests(unittest.TestCase):
    """Tests for the Carbon Model MODEL_SPEC and validation."""

    def setUp(self):
        """Create a temporary workspace."""
        self.workspace_dir = tempfile.mkdtemp()
        self.base_required_keys = [
            'workspace_dir',
            'lulc_cur_path',
            'carbon_pools_path',
            'raster_output_units',
        ]

    def tearDown(self):
        """Remove the temporary workspace after a test."""
        shutil.rmtree(self.workspace_dir)

    def test_missing_keys(self):
        """Carbon Validate: assert missing required keys."""
        from natcap.invest import carbon
        from natcap.invest import validation

        validation_errors = carbon.validate({})  # empty args dict.
        invalid_keys = validation.get_invalid_keys(validation_errors)
        expected_missing_keys = set(self.base_required_keys)
        self.assertEqual(invalid_keys, expected_missing_keys)

    def test_missing_keys_sequestration(self):
        """Carbon Validate: assert missing calc_sequestration keys."""
        from natcap.invest import carbon
        from natcap.invest import validation

        args = {'calc_sequestration': True}
        validation_errors = carbon.validate(args)
        invalid_keys = validation.get_invalid_keys(validation_errors)
        expected_missing_keys = set(
            self.base_required_keys +
            ['lulc_fut_path'])
        self.assertEqual(invalid_keys, expected_missing_keys)

    def test_missing_keys_redd(self):
        """Carbon Validate: assert missing do_redd keys."""
        from natcap.invest import carbon
        from natcap.invest import validation

        args = {'do_redd': True}
        validation_errors = carbon.validate(args)
        invalid_keys = validation.get_invalid_keys(validation_errors)
        expected_missing_keys = set(
            self.base_required_keys +
            ['calc_sequestration',
             'lulc_redd_path'])
        self.assertEqual(invalid_keys, expected_missing_keys)

    def test_missing_keys_valuation(self):
        """Carbon Validate: assert missing do_valuation keys."""
        from natcap.invest import carbon
        from natcap.invest import validation

        args = {'do_valuation': True}
        validation_errors = carbon.validate(args)
        invalid_keys = validation.get_invalid_keys(validation_errors)
        expected_missing_keys = set(
            self.base_required_keys +
            ['calc_sequestration',
             'price_per_metric_ton_of_c',
             'discount_rate',
             'rate_change',
             'lulc_cur_year',
             'lulc_fut_year'])
        self.assertEqual(invalid_keys, expected_missing_keys)
